#ifndef MYWINDOW_H
#define MYWINDOW_H

#include <QWidget>
#include <QGraphicsScene>
#include <QGraphicsView>
#include <QGraphicsItem>
#include <QGraphicsItemGroup>
#include <QGraphicsLineItem>
#include <QMouseEvent>

class MyWindow : public QWidget
{
    Q_OBJECT

public:
    MyWindow(QWidget *parent = nullptr);

private:
    QGraphicsScene *m_scene;
    QGraphicsView *m_view;
    QGraphicsItemGroup *m_selectedItems;
    QList<QGraphicsItem*> m_items;
    QList<QGraphicsLineItem*> m_lines;
    QGraphicsLineItem *m_currentLine;

    void mousePressEvent(QMouseEvent *event);
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void createLine(const QPointF &p1, const QPointF &p2);
    void deleteLine(QGraphicsLineItem *line);
    void updateLines();

private slots:
    void updateMatrix();

signals:
    void matrixUpdated(const QList<QList<bool> > &matrix);
};

#endif // MYWINDOW_H




#include "mywindow.h"
#include <QGridLayout>
#include <QPushButton>
#include <QGroupBox>
#include <QFormLayout>
#include <QLineEdit>
#include <QLabel>

MyWindow::MyWindow(QWidget *parent)
    : QWidget(parent)
{
    m_scene = new QGraphicsScene(this);
    m_view = new QGraphicsView(m_scene, this);
    m_selectedItems = nullptr;
    m_currentLine = nullptr;

    QGroupBox *gb = new QGroupBox(tr("Create Node"));
    QFormLayout *fl = new QFormLayout;
    QLineEdit *nodeName = new QLineEdit;
    QPushButton *addNodeButton = new QPushButton(tr("Add"));
    fl->addRow(new QLabel(tr("Node Name:")), nodeName);
    fl->addRow(addNodeButton);
    gb->setLayout(fl);

    connect(addNodeButton, &QPushButton::clicked, [this, nodeName]() {
        QGraphicsEllipseItem *item = m_scene->addEllipse(-20, -20, 40, 40);
        item->setFlag(QGraphicsItem::ItemIsMovable, true);
        item->setFlag(QGraphicsItem::ItemIsSelectable, true);
        item->setPos(QCursor::pos());
        m_items.append(item);
        updateLines();
    });

    QGridLayout *layout = new QGridLayout;
    layout->addWidget(gb, 0, 0);
    layout->addWidget(m_view, 0, 1);
    setLayout(layout);

    connect(this, &MyWindow::matrixUpdated, [](const QList<QList<bool> > &matrix) {
        qDebug() << "Matrix Updated:" << matrix;
    });
}

void MyWindow::mousePressEvent(QMouseEvent *event)
{
    QGraphicsItem *item = m_scene->itemAt(event->pos(), QTransform());
    if (item && item->isSelected()) {
        m_selectedItems = m_scene->createItemGroup(m_scene->selectedItems());
        for (QGraphicsItem *i : m_selectedItems->childItems()) {
            i->setFlag(QGraphicsItem::ItemIsMovable, true);
        }
    }


void MyWindow::mouseMoveEvent(QMouseEvent *event)
{
if (m_selectedItems) {
for (QGraphicsItem *i : m_selectedItems->childItems()) {
i->setPos(i->pos() + (event->pos() - event->lastPos()));
}
updateLines();
} else if (m_currentLine) {
m_currentLine->setLine(m_currentLine->line().p1(), event->pos());
}
}

void MyWindow::mouseReleaseEvent(QMouseEvent *event)
{
if (m_selectedItems) {
m_scene->destroyItemGroup(m_selectedItems);
m_selectedItems = nullptr;
updateLines();
} else if (m_currentLine) {
QGraphicsItem *item = m_scene->itemAt(event->pos(), QTransform());
if (item && item != m_currentLine->line().p1()) {
createLine(m_currentLine->line().p1(), item->scenePos());
}
m_scene->removeItem(m_currentLine);
delete m_currentLine;
m_currentLine = nullptr;
}
}

void MyWindow::createLine(const QPointF &p1, const QPointF &p2)
{
QGraphicsLineItem *line = new QGraphicsLineItem(QLineF(p1, p2));
line->setPen(QPen(Qt::black, 2));
m_lines.append(line);
m_scene->addItem(line);
updateMatrix();
}

void MyWindow::deleteLine(QGraphicsLineItem *line)
{
m_scene->removeItem(line);
m_lines.removeAll(line);
delete line;
updateMatrix();
}

void MyWindow::updateLines()
{
for (QGraphicsLineItem *line : m_lines) {
m_scene->removeItem(line);
delete line;
}
m_lines.clear();



for (int i = 0; i < m_items.size(); ++i) {
    for (int j = 0; j < m_items.size(); ++j) {
        if (i == j) {
            continue;
        }

        QGraphicsItem *item1 = m_items.at(i);
        QGraphicsItem *item2 = m_items.at(j);

        if (!item1->isSelected() && !item2->isSelected()) {
            continue;
        }

        QPointF p1 = item1->scenePos();
        QPointF p2 = item2->scenePos();

        QGraphicsLineItem *line = new QGraphicsLineItem(QLineF(p1, p2));
        line->setPen(QPen(Qt::black, 2));
        m_lines.append(line);
        m_scene->addItem(line);
    }
}

updateMatrix();


}

void MyWindow::updateMatrix()
{
QList<QList<bool> > matrix;
for (int i = 0; i < m_items.size(); ++i) {
matrix.append(QList<bool>());
for (int j = 0; j < m_items.size(); ++j) {
if (i == j) {
matrix.last().append(false);
continue;
}


        QGraphicsItem *item1 = m_items.at(i);
        QGraphicsItem *item2 = m_items.at(j);

        if (!item1->isSelected() && !item2->isSelected()) {
            matrix.last().append(false);
            continue;
        }

        bool connected = false;
        for (QGraphicsLineItem *line : m_lines) {
            if ((line->line().p1() == item1->scenePos() && line->line().p2() == item2->scenePos()) ||
                (line->line().p1() == item2->scenePos() && line->line().p2() == item

                item1->scenePos())) {
                connected = true;
                break;
            }
        }

        matrix.last().append(connected);
    }
}

// Output the matrix
for (int i = 0; i < matrix.size(); ++i) {
    for (int j = 0; j < matrix.at(i).size(); ++j) {
        std::cout << matrix.at(i).at(j) << " ";
    }
    std::cout << std::endl;
}
}


void MyWindow::clear()
{
for (QGraphicsItem *item : m_items) {
m_scene->removeItem(item);
delete item;
}
m_items.clear();



for (QGraphicsLineItem *line : m_lines) {
    m_scene->removeItem(line);
    delete line;
}
m_lines.clear();

m_selectedItems = nullptr;
m_currentLine = nullptr;




