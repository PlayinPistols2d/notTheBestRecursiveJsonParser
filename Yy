#include <iostream>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <sstream>
#include <iterator>
#include "RPN.h"

const std::string OPS = "^/*+-";											//Supported operations
const std::string FUNCTIONS[] = {"sin", "cos", "tan", "max", "e", "pi",		//Supported functions
                                 "asin", "acos", "atan", "sinh", "cosh",
                                 "tanh", "asinh", "acosh", "atanh", "ln",
                                 "log", "sqrt", "cbrt", "ceil", "floor",
                                 "min", "abs", "phi"};

RPN::RPN()
{
}

RPN::~RPN()
{
}

/**
    Takes in a string in infix form and ouputs a vector of tokens
    corresponding to the appropriate Reverse Polish Notation representation
*/
std::vector<std::string> RPN::parseString(const std::string& exp)
{
    std::string output = "";
    std::stack<std::string> opStack;
    opStack.push(" ");

    int i = 0;
    while (i < exp.length())
    {
        // Found a numerical value
        if (isNumericalToken(exp.at(i)))
        {
            int offset = 1;
            std::string token = std::string(1, exp.at(i));

            while (i + offset < exp.size() && isNumericalToken(exp.at(i + offset)))
            {
                token += exp.at(i + offset);
                offset++;
            }

            output += token;
            output += " ";
            i += offset;
            continue;
        }
        // Found a function
        else if (isAlphaToken(exp.at(i)))
        {
            int offset = 1;
            std::string token = std::string(1, exp.at(i));

            while (i + offset < exp.size() && isAlphaToken(exp.at(i + offset)))
            {
                token += exp.at(i + offset);
                offset++;
            }

            opStack.push(token);
            i += offset;
            continue;
        }
        // Found an operator
        else if (isOperator(exp.at(i)))
        {
            std::string currentOperator(1, exp.at(i));
            if (currentOperator == "-") {
                if (i == 0 || exp.at(i - 1) == '(') {
                    // Negative sign, treat it as part of the numerical value
                    int offset = 1;
                    std::string token = currentOperator;

                    while (i + offset < exp.size() && isNumericalToken(exp.at(i + offset)))
                    {
                        token += exp.at(i + offset);
                        offset++;
                    }

                    output += token;
                    output += " ";
                    i += offset;
                    continue;
                }
            }

            while (((isFunction(opStack.top())) ||
                    (deltaPriority(currentOperator, opStack.top()) < 0)  ||
                    ((deltaPriority(currentOperator, opStack.top()) == 0) && (currentOperator != "^"))) &&
                   (opStack.top() != "("))
            {
                output += opStack.top();
                output += " ";
                opStack.pop();
            }

            opStack.push(currentOperator);
        }
        // Left bracket
        else if (exp.at(i) == '(')
        {
            opStack.push(std::string(1, exp.at(i)));
        }
        // Right bracket.
